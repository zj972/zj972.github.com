<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang-字符串大小写转换]]></title>
    <url>%2F2018%2F04%2F29%2FGolang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Go语言的string模块包含了ToLower和ToUpper函数，用于将字符串转换成小写和大写 package mainimport ( "fmt" "strings")func main() &#123; fmt.Println(strings.ToUpper("hello world")) fmt.Println(strings.ToLower("HELLO WORLD"))&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-常用函数copy]]></title>
    <url>%2F2018%2F04%2F23%2FGolang-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0copy%2F</url>
    <content type="text"><![CDATA[copy主要用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行复制。 e.g: slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;//只会复制slice1的前3个元素到slice2中copy(slice2, slice1)//只会复制slice2的3个元素到slice1的前3个位置copy(slice1, slice2) END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-JSON]]></title>
    <url>%2F2018%2F04%2F20%2FGolang-JSON%2F</url>
    <content type="text"><![CDATA[在学习JavaScript时，经常用到的数据类型是JSON，作为JavaScript衍生出来的数据结构，js可以通过encode和decode基础方法来进行对象和JSON的相互转化，而在Golang中同样有相应的包及方法来解析JSON… 类型转换规则： bool类型 转换为JSON的Boolean 整数，浮点数等数值类型 转换为JSON的Number string 转换为JSON的字符串(带””引号) struct 转换为JSON的Object，再根据各个成员的类型递归打包 数组或切片 转换为JSON的Array []byte 会先进行base64编码然后转换为JSON字符串 map 转换为JSON的Object，key必须是string interface{} 按照内部的实际类型进行转换 nil 转为JSON的null channel,func等类型 会返回UnsupportedTypeError Encodefunc Marshal(v interface{}) ([]byte, error) type ColorGroup struct &#123; ID int Name string Colors []string&#125;group := ColorGroup&#123; ID: 1, Name: "Reds", Colors: []string&#123;"Crimson", "Red", "Ruby", "Maroon"&#125;,&#125;b, err := json.Marshal(group)if err != nil &#123; fmt.Println("error:", err)&#125;os.Stdout.Write(b)Output:&#123;"ID":1,"Name":"Reds","Colors":["Crimson","Red","Ruby","Maroon"]&#125; Decodefunc Unmarshal(data []byte, v interface{}) error var jsonBlob = []byte(`[ &#123;"Name": "Platypus", "Order": "Monotremata"&#125;, &#123;"Name": "Quoll", "Order": "Dasyuromorphia"&#125;]`)type Animal struct &#123; Name string Order string&#125;var animals []Animalerr := json.Unmarshal(jsonBlob, &amp;animals)if err != nil &#123; fmt.Println("error:", err)&#125;fmt.Printf("%+v", animals)Output:[&#123;Name:Platypus Order:Monotremata&#125; &#123;Name:Quoll Order:Dasyuromorphia&#125;] 踩坑 由于js里面数值类型为Number，所以当Golang解析JSON时就统一将Number转成了float64 结构体的字段必须为大写字母开头才会被打包进JSON里面 JSON中的object会被解析为map[string]interface{}类型 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令使用]]></title>
    <url>%2F2018%2F04%2F16%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[好了，用了有一段时间的Hexo了，基于他强大的命令工具，可以节省很多时间与创建管理blog，所以是时候总结一哈它的常用命令了。 hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-类型转换之strconv包]]></title>
    <url>%2F2018%2F04%2F12%2FGolang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B9%8Bstrconv%E5%8C%85%2F</url>
    <content type="text"><![CDATA[又是一个类型转换的问题，每门语言都会踩这个坑，而且动静态语言差异还比较大，动态的不需要考虑如何转，而是需要考虑转成了什么。而go…都需要考虑了，学习一哈~ ParseBool功能：将字符串转换为布尔值 说明： func ParseBool(str string) (value bool, err error) 接受真值：1, t, T, TRUE, true, True 接受假值：0, f, F, FALSE, false, False 其它任何值都返回一个错误 用法： res, error := strconv.ParseBool(str) FormatBool功能：将布尔值转换为字符串 “true” 或 “false” 说明： func FormatBool(b bool) string 用法： str := strconv.FormatBool(0 &lt; 1) ParseFloat功能：将字符串转换为浮点数 说明： func ParseFloat(s string, bitSize int) (f float64, err error) s：要转换的字符串 bitSize：指定浮点类型（32:float32、64:float64） *如果 s 是合法的格式，而且接近一个浮点值，则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准） *如果 s 不是合法的格式，则返回“语法错误” *如果转换结果超出 bitSize 范围，则返回“超出范围” 用法： func main() &#123; s := "0.12345678901234567890" f, err := strconv.ParseFloat(s, 32) fmt.Println(f, err) // 0.12345679104328156 fmt.Println(float32(f), err) // 0.12345679 f, err = strconv.ParseFloat(s, 64) fmt.Println(f, err) // 0.12345678901234568&#125; ParseInt功能：将字符串转换为 int 类型 说明： func ParseInt(s string, base int, bitSize int) (i int64, err error) s：要转换的字符串 base：进位制（2 进制到 36 进制） bitSize：指定整数类型（0:int、8:int8、16:int16、32:int32、64:int64） 如果 base 为 0，则根据字符串的前缀判断进位制（0x:16，0:8，其它:10） 用法： func main() &#123; fmt.Println(strconv.ParseInt("123", 10, 8)) // 123 fmt.Println(strconv.ParseInt("12345", 10, 8)) // 127 strconv.ParseInt: parsing "12345": value out of range fmt.Println(strconv.ParseInt("2147483647", 10, 0)) // 2147483647 fmt.Println(strconv.ParseInt("0xFF", 16, 0)) // 0 strconv.ParseInt: parsing "0xFF": invalid syntax fmt.Println(strconv.ParseInt("FF", 16, 0)) // 255 fmt.Println(strconv.ParseInt("0xFF", 0, 0)) // 255&#125; Atoi功能：将字符串转换为 int 类型 说明： func Atoi(s string) (i int, err error) 相当于 ParseInt(s, 10, 0) 用法： func main() &#123; fmt.Println(strconv.Atoi("2147483647")) // 2147483647 fmt.Println(strconv.Atoi("2147483648")) // 2147483647 strconv.ParseInt: parsing "2147483648": value out of range&#125; FormatFloat功能：将浮点数 f 转换为字符串值 说明： func FormatFloat(f float64, fmt byte, prec, bitSize int) string 参数： f：要转换的浮点数 fmt：格式标记（b、e、E、f、g、G） prec：精度（数字部分的长度，不包括指数部分） bitSize：指定浮点类型（32:float32、64:float64） 格式标记： ‘b’ (-ddddp±ddd，二进制指数) ‘e’ (-d.dddde±dd，十进制指数) ‘E’ (-d.ddddE±dd，十进制指数) ‘f’ (-ddd.dddd，没有指数) ‘g’ (‘e’:大指数，’f’:其它情况) ‘G’ (‘E’:大指数，’f’:其它情况) 如果格式标记为 ‘e’，’E’和’f’，则 prec 表示小数点后的数字位数 如果格式标记为 ‘g’，’G’，则 prec 表示总的数字位数（整数部分+小数部分） 用法： package mainimport ( "fmt" "strconv")func main() &#123; f := 100.12345678901234567890123456789 fmt.Println(strconv.FormatFloat(f, 'b', 5, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 5, 32)) // 1.00123e+02 fmt.Println(strconv.FormatFloat(f, 'E', 5, 32)) // 1.00123E+02 fmt.Println(strconv.FormatFloat(f, 'f', 5, 32)) // 100.12346 fmt.Println(strconv.FormatFloat(f, 'g', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'G', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'b', 30, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 30, 32)) // 1.001234588623046875000000000000e+02 fmt.Println(strconv.FormatFloat(f, 'E', 30, 32)) // 1.001234588623046875000000000000E+02 fmt.Println(strconv.FormatFloat(f, 'f', 30, 32)) // 100.123458862304687500000000000000 fmt.Println(strconv.FormatFloat(f, 'g', 30, 32)) // 100.1234588623046875 fmt.Println(strconv.FormatFloat(f, 'G', 30, 32)) // 100.1234588623046875&#125; 暂时只用到了这些，其他的以后用到再做补充~ To be continued!!!]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Beego-ORM使用]]></title>
    <url>%2F2018%2F04%2F10%2FBeego-ORM%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本打算用官方包里自带的mysql来进行数据库操作的，但为了与rpc项目统一，最后选择了Beego的ORM。看了几遍文档，这里进行一下常用功能的总结。 ORM基础配置package mainimport ( "fmt" "github.com/astaxie/beego/orm" // 必须引入mysql包 _ "github.com/go-sql-driver/mysql")type User struct &#123; Id int Age int16 Name string&#125;func init() &#123; orm.RegisterDriver("mysql", orm.DRMySQL) // 需要在init中注册定义的model orm.RegisterModel(new(User)) // 链接数据库 orm.RegisterDataBase("default", "mysql", "root:root@tcp(123.123.123.123:3306)/test?charset=utf8")&#125; 对象的 CRUD 操作 Read o := orm.NewOrm()user := User&#123;Id: 1&#125;err := o.Read(&amp;user)if err == orm.ErrNoRows &#123; fmt.Println("查询不到")&#125; else if err == orm.ErrMissPK &#123; fmt.Println("找不到主键")&#125; else &#123; fmt.Println(user.Id, user.Name)&#125; 主要的逻辑就是将一个models的结构体传入o.Read()然后返回查询到完整的一条记录。 ReadOrCreate o := orm.NewOrm()user := User&#123;Name: "slene"&#125;// 三个返回参数依次为：是否新创建的，对象 Id 值，错误if created, id, err := o.ReadOrCreate(&amp;user, "Name"); err == nil &#123; if created &#123; fmt.Println("New Insert an object. Id:", id) &#125; else &#123; fmt.Println("Get an object. Id:", id) &#125;&#125; 字面意思：读取，不存在就创建 Insert o := orm.NewOrm()var user Useruser.Name = "slene"user.IsActive = trueid, err := o.Insert(&amp;user)if err == nil &#123; fmt.Println(id)&#125; 这个也简单，将一条数据新增到数据库，返回值为自增ID InsertMulti users := []User&#123; &#123;Name: "slene"&#125;, &#123;Name: "astaxie"&#125;, &#123;Name: "unknown"&#125;, ...&#125;successNums, err := o.InsertMulti(100, users) 传入的是models结构体的数组，第一个返回值为成功插入的数据量 Update o := orm.NewOrm()user := User&#123;Id: 1&#125;if o.Read(&amp;user) == nil &#123; user.Name = "MyName" if num, err := o.Update(&amp;user); err == nil &#123; fmt.Println(num) &#125;&#125; 第一个返回值为影响的行数 Delete o := orm.NewOrm()if num, err := o.Delete(&amp;User&#123;Id: 1&#125;); err == nil &#123; fmt.Println(num)&#125; 第一个返回值为影响的行数 SQL语句查询o := orm.NewOrm()var r RawSeterids := []int&#123;1, 2, 3&#125;r = o.Raw("SELECT name FROM user WHERE id IN (?, ?, ?)", ids) *注：“？”为占用符 而RawSeter下面有许多方法，用来解析返回的值，这些还没有用到，等以后进行补充。 To be continued!!!]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Beego</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-类型断言]]></title>
    <url>%2F2018%2F04%2F05%2FGolang-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于类型断言，也是在接触Golang后台语言才明白的，也就是字面意思，断言一个interface{}未知类型变量的类型 断言写法value, ok := em.(T)，即Comma-ok断言。 em代表要判断的变量 T代表被判断的类型 value代表返回的值 ok代表是否为改类型 特性 em必须是initerface{}类型，也就是说必须是为一个未知类型的变量断言 switch与类型断言的结合 package mainimport ( "fmt")type Element interface &#123;&#125;func main() &#123; var e Element = 100 switch value := e.(type) &#123; case int: fmt.Println("int", value) case string: fmt.Println("string", value) default: fmt.Println("unknown", value) &#125;&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-Error类型]]></title>
    <url>%2F2018%2F04%2F01%2FGolang-Error%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[初学Golang，发现一个特别有意思的特性，那就是func多返回值，而以前用js的时候都是组装成对象返回，这个时候就体现出了静态语言的特性了，任何方法的参数不论是数量还是类型都已经定义好了，这样虽有所限制不如js灵活，但方便了规范和封装方法。而这其中最有用的就属返回error了。 error的实质结构如下： // The error built-in interface type is the conventional interface for// representing an error condition, with the nil value representing no error.type error interface &#123; Error() string&#125; 生成一个新的errorpackage mainimport ( "errors" "fmt")type Customerror struct &#123; infoa string infob string Err error&#125;func (cerr Customerror) Error() string &#123; errorInfo := fmt.Sprintf("infoa : %s , infob : %s , original err info : %s ", cerr.infoa, cerr.infob, cerr.Err.Error()) return errorInfo&#125;func main() &#123; //方法一： //采用errors包的New方法 返回一个err的类型 var err error = errors.New("this is a new error") //由于已经实现了error接口的方法 因此可以直接调用对应的方法 fmt.Println(err.Error()) //方法二： //采用fmt.Errof 将string信息转化为error信息 并返回 err = fmt.Errorf("%s", "the error test for fmt.Errorf") fmt.Println(err.Error()) //方法三： //采用自定义的方式实现一个error的 一个duck 类型 err = &amp;Customerror&#123; infoa: "err info a", infob: "err info b", Err: errors.New("test custom err"), &#125; fmt.Println(err.Error())&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt.Printf初学]]></title>
    <url>%2F2018%2F03%2F27%2Ffmt-Printf%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[Emmmm…好吧，对于一个学了好几年JavaScript，而从来没有接触过后台的菜鸡，我对printf的了解还是当年大一学C的时候了。用习惯了console，感觉printf非常别扭，只能说弱类型语言太灵活了！ 来吧，列举下一些常见的格式化输出… General %v 以默认的方式打印变量的值 %T 打印变量的类型 Integer %+d 带符号的整型，fmt.Printf(&quot;%+d&quot;, 255) 输出 +255 %q 打印单引号 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带0x的十六进制 %U 打印Unicode字符 %#U 打印带字符的Unicode %b 打印整型的二进制 Integer width %5d 表示该整型最大长度是5 fmt.Printf("|%5d|", 1) //| 1|fmt.Printf("|%5d|", 1234567) //|1234567| Integer width（续） %-5d 则相反，打印结果会自动左对齐 %05d 会在数字前面补零 Float %f(=%.6f) 6位小数点 %e(=%.6e) 6位小数点（科学计数法） %g 用最少的数字来表示 %.3g 最多3位数字来表示 %.3f 最多3位小数来表示 String %s 正常输出字符串 %q 字符串带双引号，字符串中的引号带转义符 %#q 字符串带反引号，如果字符串内有反引号，就用双引号代替 %x 将字符串转换为小写的16进制格式 %X 将字符串转换为大写的16进制格式 % x 带空格的16进制格式 String Width %5s 最小宽度为5 %-5s 最小宽度为5（左对齐） %.5s 最大宽度为5 %5.7s 最小宽度为5，最大宽度为7 %-5.7s 最小宽度为5，最大宽度为7（左对齐） %5.3s 如果宽度大于3，则截断 %05s 如果宽度小于5，就会在字符串前面补零 Struct %v 正常打印。比如：{sam {12345 67890}} %+v 带字段名称。比如：{name:sam phone:{mobile:12345 office:67890} %#v 用Go的语法打印，比如main.People{name:”sam”, phone:main.Phone{mobile:”12345”, office:”67890”}} Boolean %t 打印true或false Pointer %p 带0x的指针 %#p 不带0x的指针 printf和println的区别Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形 Println : 可以打印出字符串，和变量 END]]></content>
      <categories>
        <category>《Go语言编程》笔记</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念我人生的第一次转岗]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%89%8D%E7%AB%AF%E8%BD%AC%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[今天做了一个重大的决定，那就是前端转后台，从JavaScript到Golang。垫显示器的书将要永远垫着了… 虽然作抉择的时候彻夜难眠，但确实没有焦虑，而是在认真的一点一点地剖析两个方向、两个选择的结果。很多很多的因素，自己很难捋清楚，问了很多人，得到了各种建议，但最后将要做决定的时候，才发现还是要问自己才行。 入职培训我一直记得一句话叫做：“简单相信”，但真的让自己做选择时，相信别人的安排又是那么困难。 在面临一些重要决定时，我总是会想到父亲，在我眼里，父亲是一个活得很明白，生活阅历丰富的人。他的建议对我的人生轨迹有着很大的助力作用。父亲觉得年轻就是要多学多闯，要看得见远方，舍弃当下看似很难以割舍的东西，去追求长远的目标。 有人说：只有有能力的人才拥有选择权。但我认为有能力的人拥有的不是选择权，而是制造选择的能力。 END]]></content>
      <categories>
        <category>人生纪实</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中Next主题首页不显示全文]]></title>
    <url>%2F2018%2F03%2F14%2FHexo%E4%B8%ADNext%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[使用Next主题时，会发现它在首页默认是会显示全文的，这就很不方便浏览文章列表。 解决办法找到主题配置文件```yml# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: fales length: 150 将enable的值修改为true，而length是指显示的字数，然后重新部署就可以了~ Tips：使用预览会忽略文章的格式，直接显示为正文文本。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-theme</tag>
        <tag>theme-next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie安全探索]]></title>
    <url>%2F2018%2F03%2F14%2FCookie%E5%AE%89%E5%85%A8%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[在使用前端保存数据时，我通常会使用LocalStorage，相较于Cookie，前者更方便，容量更大，而且保存时间长。但是对于后端来说，我们同样需要在前端保存一些数据并与之交互，也就是在HTTP头中携带Cookie。 Cookie的基本属性 name（名称） value（值） domain（子域） path（站点路径） expires/Max-Age（过期时间） Size（大小） http（仅HTTP读取） secure（安全性） 具体的属性用法，网上都有介绍，就不一一赘述 Cookie安全问题 不唯一：Cookie是由三元组[name, domain, path]来确定的，是会出现重名，即不是唯一的 易于获取：前面提到了Cookie是被携带在HTTP上面的，所以很容易从请求上截取到Cookie Cookie注入：容易截取的同时，Cookie也易于修改 思考基于上面的问题，我有思考过当前我所做的项目存在的安全问题，虽然只是一个内部的管理页面，有内网限制。但公司员工如果发现安全漏洞，岂不是可以攻击系统了。 看了很多相关的博文，对我当前项目的Cookie进行了一些基础的防护： 将一些较为敏感的信息作为post请求字段进行传递 对系统的用户输入提交进行脚本过滤 设置secure为true 设置HTTPOnly属性 定期自动清理一些不必要的Cookie字段 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git子模块-初遇]]></title>
    <url>%2F2018%2F03%2F05%2FGit%E5%AD%90%E6%A8%A1%E5%9D%97-%E5%88%9D%E9%81%87%2F</url>
    <content type="text"><![CDATA[使用Git已经有好几年了，但是从来没有使用过Git的子模块，因为大多数项目都是独立的，项目之间并没有包含关系。所谓子模块，也就是将一个Git仓库作为另一个Git仓库的子目录，然后在大的仓库里进行模块化管理子仓库。 问题初探在搭建Blog的过程中，有使用到Hexo的主题next，在提交代码到Git上时，发现next文件无法commit： $ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: themes/next (modified content)no changes added to commit (use "git add" and/or "git commit -a") 看了一下网上的解释，原来是因为我是clone的代码，next文件下有.git的存在，只需要删除就可以。删除虽然可以解决问题，但这样就无法更新next了，如果下载后手动合并自己的修改又过于麻烦。而且由于我是深度修改了next，很多文件都进行了修改，所以无法像issues那样，提取个人的配置，不对next进行修改。 子模块使用这时候看到有人提到了fork+submodule的方法，大概意思就是将next项目fork到自己的GitHub上，然后clone下来并作为子模块进行管理，这样既可以修改next并上传保存，也可以update作者的代码。 操作步骤先clone并建立子模块 $ git submodule add https://github.com/zj972/hexo-theme-next themes/next 进行完这一步操作就会clone仓库代码到对应路径，同时还会在根目录下生成一个.gitmodules文件，该配置文件保存着仓库链接和本地目录的映射关系： $ cat .gitmodules[submodule "themes/next"] path = themes/next url = https://github.com/zj972/hexo-theme-next 然后就可以进行子模块的修改和操作了，作为刚用上这个命令不太熟的，其实可以直接进入到子仓库目录下进行git操作。 一下是几条操作的示例： 查看详细的差异信息 $ git diff --cached --submodule 克隆包含有子模块的项目 $ git clone git@github.com:zj972/blog.git 这个时候子模块目录是空的，需要通过submodule进行更新 $ git submodule init$ git submodule update 其他的子模块操作还在尝试中… END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Page绑定个人域名]]></title>
    <url>%2F2018%2F03%2F02%2FGitHub_Page%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[自己的服务器到期了，然后打算在GitHub上面搭个个人博客玩玩，最后选择了Hexo。搭建起来后，用自己的域名绑定了GitHub Page。 但是遇到一个问题：每次hexo d -g之后，访问www.yangshaobo.cn就变成了404。DNS解析是正常的，打开项目的setting，却发现Custom domain的值为空。 发现问题原来当你添加个人域名时，GitHub会向你的项目仓库添加一个文件CNAME，里面包含了一个域名： www.yangshaobo.cn 而每次我使用通过Hexo部署时都会自动提交public文件夹到仓库里，配置信息如下： deploy: type: git repository: git@github.com:zj972/zj972.github.com.git branch: master 这样就把CNAME文件自动覆盖了。 解决方案解决办法就是把CNAME文件添加到source文件夹里，这样每次部署就不会覆盖掉了。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
