<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang-goroutine的调度]]></title>
    <url>%2F2018%2F07%2F13%2FGolang-goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[谈及这个话题，最初的出发点是朋友问我：“goroutine的调度是抢占式的还是非抢占式的”？所以就有了以下的总结。 什么是goroutine要知道什么是goroutine，那么就要对以下几个定义有所了解： 进程（Process）：在内存中的程序。有自己独立的独占的虚拟 CPU 、虚拟的 Memory、虚拟的 IO devices。 线程（Thread）：轻量级进程。在现代操作系统中，是进程中程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。 协程（coroutine/fiber）：轻量级线程。 是可以并发执行的函数，由编译或用户指定位置将控制权交给协程调度程序执行的方式。它是非抢占式的，可以避免反复系统调用，还有进程切换造成的开销，给你上几千个逻辑流，也称用户级别线程。 而goroutine，可以认为是协程的go语言实现，也可以说是轻量级线程(即协程coroutine），但作者Rob Pike并不这么说：“一个Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。” 抢占式和非抢占式非抢占式（Nonpreemptive）让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统 抢占式（Preemptive）允许将逻辑上可继续运行的在运行过程暂停的调度方式，可防止单一进程长时间独占CPU，系统开销大 goroutine的进化史G-M模型（Go 1.0）在这个调度器中，每个goroutine对应于runtime中的一个抽象结构：G，而os thread作为“物理CPU”的存在而被抽象为一个结构：M(machine)。 G-P-M模型（Go 1.1）P是一个“逻辑Proccessor”，每个G要想真正运行起来，首先需要被分配一个P（进入到P的local runq中，这里暂忽略global runq那个环节）。对于G来说，P就是运行它的“CPU”，可以说：G的眼里只有P。但从Go scheduler视角来看，真正的“CPU”是M，只有将P和M绑定才能让P的runq中G得以真实运行起来。这样的P与M的关系，就好比Linux操作系统调度层面用户线程(user thread)与核心线程(kernel thread)的对应关系那样(N x M)。 “抢占式”调度（Go 1.2）这个抢占式调度的原理则是在每个函数或方法的入口，加上一段额外的代码，让runtime有机会检查是否需要执行抢占调度。这种解决方案只能说局部解决了“饿死”问题，对于没有函数调用，纯算法循环计算的G，scheduler依然无法抢占。 e.g： package mainimport ( "fmt" "runtime")func main() &#123; // 设置为只有一个P runtime.GOMAXPROCS(1) go func() &#123; for &#123; fmt.Println("hello world") &#125; &#125;() // 由于没有函数方法调用，P只会堵死在这个G上，而上一个G会被“饿死”。 go func() &#123; for &#123; //fmt.Println("hello") &#125; &#125;() select &#123;&#125;&#125; 参考链接：1.goroutine的调度 2.five-things-that-make-go-fast 结论：根据参考文章，可以知道goroutine的调度是基于G-P-M模型的，他本身就是一种非抢占式调度。文章中提到Go 1.2的版本优化，通过runtime检查执行抢占，实现了“抢占调度”，但仍然会有无法运行runtime检查的情况（即文章中提到的各种阻塞）。综上所述，goroutine是非抢占式的，通过协作来进行调度。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端-WebSocket]]></title>
    <url>%2F2018%2F07%2F08%2FWeb%E5%89%8D%E7%AB%AF-WebSocket%2F</url>
    <content type="text"><![CDATA[之前做前端大部分请求都是普通的HTTP请求，并没有接触过WebSocket，最近在做一个日志展示，需要实时输出，所以就用到了WebSocket，这里主要记录一下前端，也就是客户端的操作。 // 打开一个WebSocket连接let ws = new WebSocket('ws://192.168.201.182:9001/pods/stdout/tails')// 当打开连接时的操作ws.onopen = () =&gt; &#123; // 由于业务需求，要在打开时发送参数请求 ws.send('something')&#125;// 当关闭连接时的操作// 注意：这里的关闭是指服务端关闭this.ws.onclose = () =&gt; &#123; // do something&#125;// 收到数据时的操作this.ws.onmessage = (msg) =&gt; &#123; // do something&#125;// 收到错误时的操作this.ws.onerror = (e) =&gt; &#123; // do something&#125; 上面注册的ws连接，有两个基础方法： ws.send()：主动发送请求给后台，参数是一个字符串，格式自己定义。 ws.close()：发送一个请求，告知后台要关闭连接，当收到响应时会出发ws.onclose()，此时这个WebSocket连接就已经关闭了。 同时ws有一个常用的基础方法ws.readyState，表示当前socket的连接状态： 0 - 表示连接尚未建立。 1 - 表示连接已建立，可以进行通信。 2 - 表示连接正在进行关闭（即前端触发ws.close()但还未收到响应）。 3 - 表示连接已经关闭或者连接不能打开。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-信号处理]]></title>
    <url>%2F2018%2F06%2F30%2FGolang-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[当进程正在执行时，通常会通过kill -9 PID来将其结束，这个时候的操作就是向进程传递一个信号，进程收到信号就会进行对应的操作，9就是最常用到的杀掉进程操作。 信号类型 信号 值 动作 说明 SIGHUP 1 Term 终端控制进程结束(终端连接断开) SIGINT 2 Term 用户发送INTR字符(Ctrl+C)触发 SIGQUIT 3 Core 用户发送QUIT字符(Ctrl+/)触发 SIGILL 4 Core 非法指令(程序错误、试图执行数据段、栈溢出等) SIGABRT 6 Core 调用abort函数触发 SIGFPE 8 Core 算术运行错误(浮点运算错误、除数为零等) SIGKILL 9 Term 无条件结束程序(不能被捕获、阻塞或忽略) SIGSEGV 11 Core 无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作) SIGPIPE 13 Term 消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作) SIGALRM 14 Term 时钟定时信号 SIGTERM 15 Term 结束程序(可以被捕获、阻塞或忽略) SIGUSR1 30,10,16 Term 用户保留 SIGUSR2 31,12,17 Term 用户保留 SIGCHLD 20,17,18 Ign 子进程结束(由父进程接收) SIGCONT 19,18,25 Cont 继续执行已经停止的进程(不能被阻塞) SIGSTOP 17,19,23 Stop 停止进程(不能被捕获、阻塞或忽略) SIGTSTP 18,20,24 Stop 停止进程(可以被捕获、阻塞或忽略) SIGTTIN 21,21,26 Stop 后台程序从终端中读取数据时触发 SIGTTOU 22,22,27 Stop 后台程序向终端中写数据时触发 Golang中信号的应用一个简单的例子： package mainimport ( "fmt" "os" "os/signal" "time")func main() &#123; go signalListen() time.Sleep(time.Hour)&#125;func signalListen() &#123; c := make(chan os.Signal) signal.Notify(c) for &#123; s := &lt;-c //收到信号后的处理，这里只是输出信号内容，可以做一些更有意思的事 fmt.Println("get signal:", s) os.Exit(1) &#125;&#125; 首先make一个channel，它的类型是os.Signal，然后用signal.Notify来注册，这样当有信号传入进程时，c就可以接收到，同时通过channel机制执行接收到数据后的操作。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>第三方包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-定时任务之cron]]></title>
    <url>%2F2018%2F06%2F25%2FGolang-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B9%8Bcron%2F</url>
    <content type="text"><![CDATA[在开发数据组件的过程中遇到了一个场景：通过redis缓存了一些数据操作，需要定时的将数据落地，这个时候就想到了使用Linux中的crontab，但遇到问题是，这个要执行的数据落地需要使用组件进程的一些内存数据，所以只能在当前进程下完成定时任务，没有办法使用系统级别的进程定时。 cron包地址是：github.com/robfig/cron，它的优点就是可以在当前进程跑某个goroutine，而且可以精确到秒。 实例package mainimport ( "github.com/robfig/cron" "log")func main() &#123; i := 0 c := cron.New() spec := "0 10,20,30,40,50 * * * ?" c.AddFunc(spec, func() &#123; i++ log.Println("cron running:", i) &#125;) c.Start() select&#123;&#125;&#125; 输出结果： 启动后输出如下：2018/06/25 18:00:00 cron running: 12018/06/25 18:10:00 cron running: 22018/06/25 18:20:00 cron running: 32018/06/25 18:30:00 cron running: 42018/06/25 18:40:00 cron running: 5 格式基础格式在cron中，最关键的是一个字符串，他包括了6个参数，并用空格隔开。 字段含义 必须 值范围 特殊字符 秒(Seconds) 是 0-59 * / , - 分(Minutes) 是 0-59 * / , - 时(Hours) 是 0-23 * / , - 日(Day of month) 是 1-31 * / , - ? 月(Month) 是 0-12 or JAN-DEC * / , - 星期(Day of week) 否 0-6 or SUM-SAT * / , - ? 注：字母不区分大小写 特殊字符 星号(*) 表示 cron 表达式能匹配该字段的所有值。如在第5个字段使用星号(month)，表示每个月 斜线(/) 表示增长间隔，如第1个字段(minutes) 值是 3-59/15，表示每小时的第3分钟开始执行一次，之后每隔 15 分钟执行一次（即 3、18、33、48 这些时间点执行），这里也可以表示为：3/15 逗号(,) 用于枚举值，如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行 连字号(-) 表示一个范围，如第3个字段的值为 9-17 表示 9am 到 5pm 直接每个小时（包括9和17） 问号(?) 只用于日(Day of month)和星期(Day of week)，\表示不指定值，可以用于代替 * END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>第三方包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL8-error_2059]]></title>
    <url>%2F2018%2F06%2F13%2FMySQL8-error_2059%2F</url>
    <content type="text"><![CDATA[错误信息： 2059 - Authentication plugin &apos;caching-sha2-password&apos; cannot be loaded: 错误原因： 这个错误出现在通过客户端连接MySQL8时，错误原因很简单，在安装MySQL8时选择了强加密规则caching_sha2_password，而客户端并不支持新的加密规则，所以会报错。 解决方案： #修改加密规则ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;#更新一下用户的密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';#如果不行再执行以下命令#刷新权限FLUSH PRIVILEGES;#再重置下密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'password'; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-输出行列控制]]></title>
    <url>%2F2018%2F06%2F07%2FLinux-%E8%BE%93%E5%87%BA%E8%A1%8C%E5%88%97%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[接触到需要控制行和列输出是在获取进程id的场景，需用执行shell去结束对应的进程然后重启。 我是通过端口号来获取进程id的，所以使用的命令是lsof -i:22，得到的结果时： [root@localhost ~]# lsof -i:22COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsshd 1235 root 3u IPv4 22942 0t0 TCP *:ssh (LISTEN)sshd 1235 root 4u IPv6 22944 0t0 TCP *:ssh (LISTEN) 但我只需要第二行第二个参数，这个时候就需要用到awk和sed命令了： [root@localhost ~]# lsof -i:22 | awk '&#123;print $2&#125;'PID12351235[root@localhost ~]# lsof -i:22 | awk '&#123;print $2&#125;' | sed -n '2p'1235 而awk命令是输出哪一列，sed是输出哪一行，最后得到pid就可以通过kill -9 1235来杀掉进程了。 关于sed，awk的其他功能待续… To be continued!!!]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-配置读取viper]]></title>
    <url>%2F2018%2F05%2F22%2FGolang-%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96viper%2F</url>
    <content type="text"><![CDATA[在自己写的组件里面，通常会遇到一些需要读取配置文件的情况。在使用beego时，是使用自带的方法获取./conf/app.conf文件中的内容，但在一个非beego框架的组件里并不想引入beego，于是乎学习了另外一个专门用来读取配置的包：“viper”。 功能特征 设置默认值 从JSON，toml YAML，HCl,和java属性配置文件 从环境变量env读取值 读缓冲区 远程读取配置文件 key不区分大小写 初始化func init() &#123; //读取conf.toml配置信息 flag.IntVar(&amp;Port, "p", 5000, "监听的端口") flag.StringVar(&amp;ConfigPath, "c", "./conf/conf.toml", "配置文件的地址") flag.Parse() filenameWithSuffix := path.Base(ConfigPath) filePath := path.Dir(ConfigPath) fileSuffix := path.Ext(filenameWithSuffix) var filenameOnly string filenameOnly = strings.TrimSuffix(filenameWithSuffix, fileSuffix) viper.SetConfigType("toml") viper.SetConfigName(filenameOnly) //不带后缀的文件名 viper.AddConfigPath(filePath) err := viper.ReadInConfig() if err != nil &#123; plog.VFatal("Fatal error config file: %v", err) &#125;&#125; 存取配置viper包下有很多的Get开头的方法，对应着不同类型数据的获取，常用的如GetInt()，GetString()，GetIntSlice()，GetStringSlice()等等，都非常好理解，同样的取数据就是Set开头 phalgo.Config.Get(key string) : interface{} phalgo.Config.GetBool(key string) : bool phalgo.Config.GetFloat64(key string) : float64 phalgo.Config.GetInt(key string) : int phalgo.Config.GetString(key string) : string phalgo.Config.GetStringMap(key string) : map[string]interface{} phalgo.Config.GetStringMapString(key string) : map[string]string phalgo.Config.GetStringSlice(key string) : []string phalgo.Config.GetTime(key string) : time.Time phalgo.Config.GetDuration(key string) : time.Duration phalgo.Config.IsSet(key string) : bool [ljy__user] key_type = 1 sharding = "test" ttl = 2592000 order = ["id", "name", "age", "sex"] [ljy__user.key] item = ["id"] item_type = ["int32"] [ljy__user.field] item = ["id"] item_type = ["int32"] [ljy__user.value] item = ["name", "age", "sex"] item_type = ["string", "int64", "string"] 对于上面的配置例子就包含了int，string，[]string的类型，同时也有子元素的存取，就像结构体一样。 SubTableField := viper.GetString("ljy__user.sharding")SubTableMod := viper.GetInt("ljy__user.key_type")Item := viper.GetStringSlice("ljy__user.key.item") END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>第三方包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-日期格式转换]]></title>
    <url>%2F2018%2F05%2F16%2FGolang-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近遇到了一些日期类型转换的问题，字符串转date类型，时间的加减以及时分秒的获取等等…参考官网这里做一下总结。 在time包里主要有以下几个数据类型：time.Time，time.Month，time.Weekday，time.Duration，time.Location time.Timetime.Time 代表一个纳秒精度的时间点. type Time struct &#123; sec int64 // 从1年1月1日 00:00:00 UTC 至今过去的秒数 nsec int32 // 最近一秒到下一秒过去的纳秒数 loc *Location // 时区&#125; time.Monthtype Month int// 相关常量const ( January Month = 1 + iota February March April May June July August September October November December) time.Weekdaytype Weekday int// 相关常量const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday) time.Durationtime.Duration 类型代表两个时间点之间经过的纳秒数，可表示的最长时间段约为290年。 type Duration int64// 相关常量const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute) time.LocationLocation代表一个地点，以及该地点所在的时区信息。北京时间可以使用Asia/Shanghai type Location struct &#123; name string zone []zone tx []zoneTrans cacheStart int64 cacheEnd int64 cacheZone *zone&#125;// 预定义时区变量var UTC *Location = &amp;utcLocvar Local *Location = &amp;localLoc 获取时间 func Now() Time {} // 当前本地时间 func Unix(sec int64, nsec int64) Time {} // 根据时间戳返回本地时间 func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {} // 返回指定时间 func (t Time) UTC() Time {} // 获取指定时间在UTC 时区的时间表示 func (t Time) Local() Time {} // 以本地时区表示 func (t Time) In(loc *Location) Time {} // 时间在指定时区的表示 func (t Time) Format(layout string) string {} // 按指定格式显示时间 // 当前本地时间t = time.Now()fmt.Println("'time.Now': ", t)// 根据时间戳返回本地时间t_by_unix := time.Unix(1487780010, 0)fmt.Println("'time.Unix': ", t_by_unix)// 返回指定时间t_by_date := time.Date(2017, time.Month(2), 23, 1, 30, 30, 0, l)fmt.Println("'time.Date': ", t_by_date)// 获取指定时间在UTC 时区的时间表示t_by_utc := t.UTC()fmt.Println("'t.UTC': ", t_by_utc)// 获取本地时间表示t_by_local := t.Local()fmt.Println("'t.Local': ", t_by_local)// 时间在指定时区的表示t_in := t.In(time.UTC)fmt.Println("'t.In': ", t_in)// Formatfmt.Println("t.Format", t.Format(time.RFC3339)) 获取日期 func (t Time) Date() (year int, month Month, day int) {} // 返回时间的日期信息 func (t Time) Year() int {} // 返回年 func (t Time) Month() Month {} // 月 func (t Time) Day() int {} // 日 func (t Time) Weekday() Weekday {} // 星期 func (t Time) ISOWeek() (year, week int) {} // 返回年，星期范围编号 func (t Time) Clock() (hour, min, sec int) {} // 返回时间的时分秒 func (t Time) Hour() int {} // 返回小时 func (t Time) Minute() int {} // 分钟 func (t Time) Second() int {} // 秒 func (t Time) Nanosecond() int {} // 纳秒 func (t Time) YearDay() int {} // 一年中对应的天 func (t Time) Location() *Location {} // 时间的时区 func (t Time) Zone() (name string, offset int) {} // 时间所在时区的规范名和想对UTC 时间偏移量 func (t Time) Unix() int64 {} // 时间转为时间戳 func (t Time) UnixNano() int64 {} // 时间转为时间戳（纳秒） // 返回时间的日期信息year, month, day := t.Date()fmt.Println("'t.Date': ", year, month, day)// 星期week := t.Weekday()fmt.Println("'t.Weekday': ", week)// 返回年，星期范围编号year, week_int := t.ISOWeek()fmt.Println("'t.ISOWeek': ", year, week_int)// 返回时间的时分秒hour, min, sec := t.Clock()fmt.Println("'t.Clock': ", hour, min, sec) 暂时只用到了这些，后面还有些序列化以及比较的方法，以后用到再做补充~ To be continued!!!]]></content>
      <categories>
        <category>《Go语言编程》笔记</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-nohup命令]]></title>
    <url>%2F2018%2F05%2F11%2FLinux-nohup%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[在golang的项目中，正常情况下，我去调试时，都是用go run main.go的命令来执行的，这样可以在命令行中查看打印的日志，但如果要把一个项目部署到服务器就必须让他自动执行，同时将日志打印到文件里存储。看了别人网上的建议，就学习了一下nohup命令 语法及描述 语法：nohup Command [ Arg … ] [ &amp; ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示”and”的符号）到命令的尾部。无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 可以说这个命令很符合预期，同时考虑到端口占用问题，就一并写在了shell里面，以下是我的start文件： service iptables stopserverId=`ps -ef | grep '/home/go/src/main' | grep -v 'grep' | awk '&#123;print $2&#125;'`if [ $serverId ]then kill -9 $serverIdfinohup /home/go/src/main &amp; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-通过反射将map数组转为结构体数组]]></title>
    <url>%2F2018%2F05%2F06%2FGolang-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%B0%86map%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[做这个的需求是这样的，我在写一个数据组件，用来统一多个类型数据库的组件，简单的说就是通过tcp请求传入一个SQL语句，就会返回类似于mysql的相应结果，同时可以确保MySQL，Redis的数据一致性，初衷是为了减少MySQL的查询次数。 而最初的查询返回统一是一个map数组，也就是[]map[string]interface{}，但有一个问题就是，客户端拿到数据后，需要对类型进行断言，这里参考了orm的源码，以及网上的一些文章，然后用反射完成了单个结构体赋值，也就是orm中的err := o.Read(&amp;user)，做数组时参考了orm中的func (o *rawSet) QueryRows(containers ...interface{}) (int64, error) 遇到的问题： CanSet()方法返回false：解决方法就是传地址，这里所有的Can类型检测方法就是针对当前的reflect.Value进行校验，如果是一个地址类的value，那就可以进行相应的修改。 结构体赋值问题：要想访问结构体中的字段，有一个大前提条件就是首字母大写，而正常情况下MySQL存储的字段是下划线连接的小写字母，通过json包转换为golang的字段就变成了驼峰，但首字母是小写，这时候就要进行首字母处理。 数组增加元素：首先是要通过反射获取到数组元素的类型，然后通过类型去new一个结构体的实例出来，这里用到了reflect.New()方法，同时在最后的时候，要进行深度拷贝才可以将数组完全赋值给传进来的地址上。 代码如下：package mainimport ( "errors" "fmt" "reflect" "strings")func main() &#123; mList := []map[string]interface&#123;&#125;&#123; &#123;"Id": 213, "Name": "zhaoliu", "Sex": "男"&#125;, &#123;"Id": 56, "Name": "zhangsan", "Sex": "男"&#125;, &#123;"Id": 7, "Name": "lisi", "Sex": "女"&#125;, &#123;"Id": 978, "Name": "wangwu", "Sex": "男"&#125;, &#125; type User struct &#123; Id int Name string Sex string &#125; users := []*User&#123;&#125; mapToStruct(mList, &amp;users) fmt.Printf("users: %+v\n", users)&#125;func mapToStruct(mList []map[string]interface&#123;&#125;, model interface&#123;&#125;) (err error) &#123; val := reflect.Indirect(reflect.ValueOf(model)) typ := val.Type() fmt.Printf("val: %v\n", val) fmt.Printf("typ: %v\n", typ) for _, r := range mList &#123; mVal := reflect.Indirect(reflect.New(typ.Elem().Elem())).Addr() //fmt.Printf("mVal: %+v\n", mVal) for key, val := range r &#123; err = setField(mVal.Interface(), key, val) if err != nil &#123; return err &#125; &#125; //fmt.Printf("mVal: %+v\n", mVal) val = reflect.Append(val, mVal) &#125; fmt.Printf("val: %+v\n", val.Interface()) //model = val.Interface() return err&#125;//用map的值替换结构的值func setField(obj interface&#123;&#125;, name string, value interface&#123;&#125;) error &#123; // 将首字母转换为大写 sl := strings.Split(name, "") sl[0] = strings.ToUpper(sl[0]) name = strings.Join(sl, "") structValue := reflect.ValueOf(obj).Elem() //结构体属性值 //fmt.Printf("structValue: %+v\n", structValue) structFieldValue := structValue.FieldByName(name) //结构体单个属性值 //fmt.Printf("structFieldValue: %+v\n", structFieldValue) if !structFieldValue.IsValid() &#123; return fmt.Errorf("No such field: %s in obj", name) &#125; if !structFieldValue.CanSet() &#123; return fmt.Errorf("Cannot set %s field value", name) &#125; structFieldType := structFieldValue.Type() //结构体的类型 val := reflect.ValueOf(value) //map值的反射值 if structFieldType != val.Type() &#123; return errors.New("type is err") &#125; structFieldValue.Set(val) return nil&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>反射</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域POST请求发送两次请求的情况详解]]></title>
    <url>%2F2018%2F05%2F03%2F%E8%B7%A8%E5%9F%9FPOST%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%83%85%E5%86%B5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在制作golang组件的过程中，打算开发一个小工具用来配置组件的参数，后台用到了beego。在此期间遇到了一个问题：我在发送一个post请求时，在控制台总会看到两次请求，于是打算进一步地了解一下请求机制，并消去多余的HTTP请求。 请求头： 可以看到Request Method是OPTIONS，而不是POST，同时也没有对应的参数，看了网上的说法才了解到，第一次请求是用来进行预检，检查你是否有权限去进行此次的POST请求，而第二次请求就是正确的POST的请求了： beego的设置：beego.InsertFilter("*", beego.BeforeRouter, cors.Allow(&amp;cors.Options&#123; AllowOrigins: []string&#123;"http://dtsvr-tool.oa.com"&#125;, AllowMethods: []string&#123;"GET", "POST", "PUT", "DELETE", "OPTIONS"&#125;, AllowHeaders: []string&#123;"Origin", "Authorization", "Access-Control-Allow-Origin", "Access-Control-Allow-Headers", "Content-Type"&#125;, ExposeHeaders: []string&#123;"Content-Length", "Access-Control-Allow-Origin", "Access-Control-Allow-Headers", "Content-Type"&#125;, AllowCredentials: true,&#125;)) 而有次校验的原因是我发送了一个非简单请求，也是头一次听说这个词，于是就搜索了一哈： 非简单请求：只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型 (Content-Type) 只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。 那按照上述所说，只要把请求改成简单请求就可以了，方法有两个： 将post请求改为get请求 axios.interceptors.request.use(function (config) &#123; config.withCredentials = true if (config.method === 'post' &amp;&amp; config.data.constructor.name !== 'FormData') &#123; let params = &#123;&#125; let str = [] for (let k in config.data) &#123; if (typeof config.data[k] !== 'function') &#123; // 参数是对象，并且不为空 if (typeof config.data[k] === 'object') &#123; params[k] = JSON.stringify(config.data[k]) &#125; else &#123; params[k] = config.data[k] &#125; &#125; &#125; Object.keys(params).map(function (key) &#123; str.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key])) &#125;) config.data = str.join('&amp;') &#125; // Do something before request is sent return config&#125;, function (error) &#123; // Do something with request error return Promise.reject(error)&#125;) 将post的header改为application/x-www-form-urlencoded,multipart/form-data或者text/plain config.headers = 'application/x-www-form-urlencoded;charset=utf-8' 这样我们就可以忽略掉预检请求，而只发送一次请求了。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>AJAX</tag>
        <tag>跨域请求</tag>
        <tag>BeeGo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-字符串大小写转换]]></title>
    <url>%2F2018%2F04%2F29%2FGolang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Go语言的string模块包含了ToLower和ToUpper函数，用于将字符串转换成小写和大写 package mainimport ( "fmt" "strings")func main() &#123; fmt.Println(strings.ToUpper("hello world")) fmt.Println(strings.ToLower("HELLO WORLD"))&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-常用函数copy]]></title>
    <url>%2F2018%2F04%2F23%2FGolang-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0copy%2F</url>
    <content type="text"><![CDATA[copy主要用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行复制。 e.g: slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;//只会复制slice1的前3个元素到slice2中copy(slice2, slice1)//只会复制slice2的3个元素到slice1的前3个位置copy(slice1, slice2) END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-JSON]]></title>
    <url>%2F2018%2F04%2F20%2FGolang-JSON%2F</url>
    <content type="text"><![CDATA[在学习JavaScript时，经常用到的数据类型是JSON，作为JavaScript衍生出来的数据结构，js可以通过encode和decode基础方法来进行对象和JSON的相互转化，而在Golang中同样有相应的包及方法来解析JSON… 类型转换规则： bool类型 转换为JSON的Boolean 整数，浮点数等数值类型 转换为JSON的Number string 转换为JSON的字符串(带””引号) struct 转换为JSON的Object，再根据各个成员的类型递归打包 数组或切片 转换为JSON的Array []byte 会先进行base64编码然后转换为JSON字符串 map 转换为JSON的Object，key必须是string interface{} 按照内部的实际类型进行转换 nil 转为JSON的null channel,func等类型 会返回UnsupportedTypeError Encodefunc Marshal(v interface{}) ([]byte, error) type ColorGroup struct &#123; ID int Name string Colors []string&#125;group := ColorGroup&#123; ID: 1, Name: "Reds", Colors: []string&#123;"Crimson", "Red", "Ruby", "Maroon"&#125;,&#125;b, err := json.Marshal(group)if err != nil &#123; fmt.Println("error:", err)&#125;os.Stdout.Write(b)Output:&#123;"ID":1,"Name":"Reds","Colors":["Crimson","Red","Ruby","Maroon"]&#125; Decodefunc Unmarshal(data []byte, v interface{}) error var jsonBlob = []byte(`[ &#123;"Name": "Platypus", "Order": "Monotremata"&#125;, &#123;"Name": "Quoll", "Order": "Dasyuromorphia"&#125;]`)type Animal struct &#123; Name string Order string&#125;var animals []Animalerr := json.Unmarshal(jsonBlob, &amp;animals)if err != nil &#123; fmt.Println("error:", err)&#125;fmt.Printf("%+v", animals)Output:[&#123;Name:Platypus Order:Monotremata&#125; &#123;Name:Quoll Order:Dasyuromorphia&#125;] 踩坑 由于js里面数值类型为Number，所以当Golang解析JSON时就统一将Number转成了float64 结构体的字段必须为大写字母开头才会被打包进JSON里面 JSON中的object会被解析为map[string]interface{}类型 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令使用]]></title>
    <url>%2F2018%2F04%2F16%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[好了，用了有一段时间的Hexo了，基于他强大的命令工具，可以节省很多时间与创建管理blog，所以是时候总结一哈它的常用命令了。 hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-类型转换之strconv包]]></title>
    <url>%2F2018%2F04%2F12%2FGolang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B9%8Bstrconv%E5%8C%85%2F</url>
    <content type="text"><![CDATA[又是一个类型转换的问题，每门语言都会踩这个坑，而且动静态语言差异还比较大，动态的不需要考虑如何转，而是需要考虑转成了什么。而go…都需要考虑了，学习一哈~ ParseBool功能：将字符串转换为布尔值 说明： func ParseBool(str string) (value bool, err error) 接受真值：1, t, T, TRUE, true, True 接受假值：0, f, F, FALSE, false, False 其它任何值都返回一个错误 用法： res, error := strconv.ParseBool(str) FormatBool功能：将布尔值转换为字符串 “true” 或 “false” 说明： func FormatBool(b bool) string 用法： str := strconv.FormatBool(0 &lt; 1) ParseFloat功能：将字符串转换为浮点数 说明： func ParseFloat(s string, bitSize int) (f float64, err error) s：要转换的字符串 bitSize：指定浮点类型（32:float32、64:float64） *如果 s 是合法的格式，而且接近一个浮点值，则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准） *如果 s 不是合法的格式，则返回“语法错误” *如果转换结果超出 bitSize 范围，则返回“超出范围” 用法： func main() &#123; s := "0.12345678901234567890" f, err := strconv.ParseFloat(s, 32) fmt.Println(f, err) // 0.12345679104328156 fmt.Println(float32(f), err) // 0.12345679 f, err = strconv.ParseFloat(s, 64) fmt.Println(f, err) // 0.12345678901234568&#125; ParseInt功能：将字符串转换为 int 类型 说明： func ParseInt(s string, base int, bitSize int) (i int64, err error) s：要转换的字符串 base：进位制（2 进制到 36 进制） bitSize：指定整数类型（0:int、8:int8、16:int16、32:int32、64:int64） 如果 base 为 0，则根据字符串的前缀判断进位制（0x:16，0:8，其它:10） 用法： func main() &#123; fmt.Println(strconv.ParseInt("123", 10, 8)) // 123 fmt.Println(strconv.ParseInt("12345", 10, 8)) // 127 strconv.ParseInt: parsing "12345": value out of range fmt.Println(strconv.ParseInt("2147483647", 10, 0)) // 2147483647 fmt.Println(strconv.ParseInt("0xFF", 16, 0)) // 0 strconv.ParseInt: parsing "0xFF": invalid syntax fmt.Println(strconv.ParseInt("FF", 16, 0)) // 255 fmt.Println(strconv.ParseInt("0xFF", 0, 0)) // 255&#125; Atoi功能：将字符串转换为 int 类型 说明： func Atoi(s string) (i int, err error) 相当于 ParseInt(s, 10, 0) 用法： func main() &#123; fmt.Println(strconv.Atoi("2147483647")) // 2147483647 fmt.Println(strconv.Atoi("2147483648")) // 2147483647 strconv.ParseInt: parsing "2147483648": value out of range&#125; FormatFloat功能：将浮点数 f 转换为字符串值 说明： func FormatFloat(f float64, fmt byte, prec, bitSize int) string 参数： f：要转换的浮点数 fmt：格式标记（b、e、E、f、g、G） prec：精度（数字部分的长度，不包括指数部分） bitSize：指定浮点类型（32:float32、64:float64） 格式标记： ‘b’ (-ddddp±ddd，二进制指数) ‘e’ (-d.dddde±dd，十进制指数) ‘E’ (-d.ddddE±dd，十进制指数) ‘f’ (-ddd.dddd，没有指数) ‘g’ (‘e’:大指数，’f’:其它情况) ‘G’ (‘E’:大指数，’f’:其它情况) 如果格式标记为 ‘e’，’E’和’f’，则 prec 表示小数点后的数字位数 如果格式标记为 ‘g’，’G’，则 prec 表示总的数字位数（整数部分+小数部分） 用法： package mainimport ( "fmt" "strconv")func main() &#123; f := 100.12345678901234567890123456789 fmt.Println(strconv.FormatFloat(f, 'b', 5, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 5, 32)) // 1.00123e+02 fmt.Println(strconv.FormatFloat(f, 'E', 5, 32)) // 1.00123E+02 fmt.Println(strconv.FormatFloat(f, 'f', 5, 32)) // 100.12346 fmt.Println(strconv.FormatFloat(f, 'g', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'G', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'b', 30, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 30, 32)) // 1.001234588623046875000000000000e+02 fmt.Println(strconv.FormatFloat(f, 'E', 30, 32)) // 1.001234588623046875000000000000E+02 fmt.Println(strconv.FormatFloat(f, 'f', 30, 32)) // 100.123458862304687500000000000000 fmt.Println(strconv.FormatFloat(f, 'g', 30, 32)) // 100.1234588623046875 fmt.Println(strconv.FormatFloat(f, 'G', 30, 32)) // 100.1234588623046875&#125; 暂时只用到了这些，其他的以后用到再做补充~ To be continued!!!]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Beego-ORM使用]]></title>
    <url>%2F2018%2F04%2F10%2FBeego-ORM%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本打算用官方包里自带的mysql来进行数据库操作的，但为了与rpc项目统一，最后选择了Beego的ORM。看了几遍文档，这里进行一下常用功能的总结。 ORM基础配置package mainimport ( "fmt" "github.com/astaxie/beego/orm" // 必须引入mysql包 _ "github.com/go-sql-driver/mysql")type User struct &#123; Id int Age int16 Name string&#125;func init() &#123; orm.RegisterDriver("mysql", orm.DRMySQL) // 需要在init中注册定义的model orm.RegisterModel(new(User)) // 链接数据库 orm.RegisterDataBase("default", "mysql", "root:root@tcp(123.123.123.123:3306)/test?charset=utf8")&#125; 对象的 CRUD 操作 Read o := orm.NewOrm()user := User&#123;Id: 1&#125;err := o.Read(&amp;user)if err == orm.ErrNoRows &#123; fmt.Println("查询不到")&#125; else if err == orm.ErrMissPK &#123; fmt.Println("找不到主键")&#125; else &#123; fmt.Println(user.Id, user.Name)&#125; 主要的逻辑就是将一个models的结构体传入o.Read()然后返回查询到完整的一条记录。 ReadOrCreate o := orm.NewOrm()user := User&#123;Name: "slene"&#125;// 三个返回参数依次为：是否新创建的，对象 Id 值，错误if created, id, err := o.ReadOrCreate(&amp;user, "Name"); err == nil &#123; if created &#123; fmt.Println("New Insert an object. Id:", id) &#125; else &#123; fmt.Println("Get an object. Id:", id) &#125;&#125; 字面意思：读取，不存在就创建 Insert o := orm.NewOrm()var user Useruser.Name = "slene"user.IsActive = trueid, err := o.Insert(&amp;user)if err == nil &#123; fmt.Println(id)&#125; 这个也简单，将一条数据新增到数据库，返回值为自增ID InsertMulti users := []User&#123; &#123;Name: "slene"&#125;, &#123;Name: "astaxie"&#125;, &#123;Name: "unknown"&#125;, ...&#125;successNums, err := o.InsertMulti(100, users) 传入的是models结构体的数组，第一个返回值为成功插入的数据量 Update o := orm.NewOrm()user := User&#123;Id: 1&#125;if o.Read(&amp;user) == nil &#123; user.Name = "MyName" if num, err := o.Update(&amp;user); err == nil &#123; fmt.Println(num) &#125;&#125; 第一个返回值为影响的行数 Delete o := orm.NewOrm()if num, err := o.Delete(&amp;User&#123;Id: 1&#125;); err == nil &#123; fmt.Println(num)&#125; 第一个返回值为影响的行数 SQL语句查询o := orm.NewOrm()var r RawSeterids := []int&#123;1, 2, 3&#125;r = o.Raw("SELECT name FROM user WHERE id IN (?, ?, ?)", ids) *注：“？”为占用符 而RawSeter下面有许多方法，用来解析返回的值，这些还没有用到，等以后进行补充。 To be continued!!!]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Beego</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-类型断言]]></title>
    <url>%2F2018%2F04%2F05%2FGolang-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于类型断言，也是在接触Golang后台语言才明白的，也就是字面意思，断言一个interface{}未知类型变量的类型 断言写法value, ok := em.(T)，即Comma-ok断言。 em代表要判断的变量 T代表被判断的类型 value代表返回的值 ok代表是否为改类型 特性 em必须是initerface{}类型，也就是说必须是为一个未知类型的变量断言 switch与类型断言的结合 package mainimport ( "fmt")type Element interface &#123;&#125;func main() &#123; var e Element = 100 switch value := e.(type) &#123; case int: fmt.Println("int", value) case string: fmt.Println("string", value) default: fmt.Println("unknown", value) &#125;&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang-Error类型]]></title>
    <url>%2F2018%2F04%2F01%2FGolang-Error%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[初学Golang，发现一个特别有意思的特性，那就是func多返回值，而以前用js的时候都是组装成对象返回，这个时候就体现出了静态语言的特性了，任何方法的参数不论是数量还是类型都已经定义好了，这样虽有所限制不如js灵活，但方便了规范和封装方法。而这其中最有用的就属返回error了。 error的实质结构如下： // The error built-in interface type is the conventional interface for// representing an error condition, with the nil value representing no error.type error interface &#123; Error() string&#125; 生成一个新的errorpackage mainimport ( "errors" "fmt")type Customerror struct &#123; infoa string infob string Err error&#125;func (cerr Customerror) Error() string &#123; errorInfo := fmt.Sprintf("infoa : %s , infob : %s , original err info : %s ", cerr.infoa, cerr.infob, cerr.Err.Error()) return errorInfo&#125;func main() &#123; //方法一： //采用errors包的New方法 返回一个err的类型 var err error = errors.New("this is a new error") //由于已经实现了error接口的方法 因此可以直接调用对应的方法 fmt.Println(err.Error()) //方法二： //采用fmt.Errof 将string信息转化为error信息 并返回 err = fmt.Errorf("%s", "the error test for fmt.Errorf") fmt.Println(err.Error()) //方法三： //采用自定义的方式实现一个error的 一个duck 类型 err = &amp;Customerror&#123; infoa: "err info a", infob: "err info b", Err: errors.New("test custom err"), &#125; fmt.Println(err.Error())&#125; END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt.Printf初学]]></title>
    <url>%2F2018%2F03%2F27%2Ffmt-Printf%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[Emmmm…好吧，对于一个学了好几年JavaScript，而从来没有接触过后台的菜鸡，我对printf的了解还是当年大一学C的时候了。用习惯了console，感觉printf非常别扭，只能说弱类型语言太灵活了！ 来吧，列举下一些常见的格式化输出… General %v 以默认的方式打印变量的值 %T 打印变量的类型 Integer %+d 带符号的整型，fmt.Printf(&quot;%+d&quot;, 255) 输出 +255 %q 打印单引号 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带0x的十六进制 %U 打印Unicode字符 %#U 打印带字符的Unicode %b 打印整型的二进制 Integer width %5d 表示该整型最大长度是5 fmt.Printf("|%5d|", 1) //| 1|fmt.Printf("|%5d|", 1234567) //|1234567| Integer width（续） %-5d 则相反，打印结果会自动左对齐 %05d 会在数字前面补零 Float %f(=%.6f) 6位小数点 %e(=%.6e) 6位小数点（科学计数法） %g 用最少的数字来表示 %.3g 最多3位数字来表示 %.3f 最多3位小数来表示 String %s 正常输出字符串 %q 字符串带双引号，字符串中的引号带转义符 %#q 字符串带反引号，如果字符串内有反引号，就用双引号代替 %x 将字符串转换为小写的16进制格式 %X 将字符串转换为大写的16进制格式 % x 带空格的16进制格式 String Width %5s 最小宽度为5 %-5s 最小宽度为5（左对齐） %.5s 最大宽度为5 %5.7s 最小宽度为5，最大宽度为7 %-5.7s 最小宽度为5，最大宽度为7（左对齐） %5.3s 如果宽度大于3，则截断 %05s 如果宽度小于5，就会在字符串前面补零 Struct %v 正常打印。比如：{sam {12345 67890}} %+v 带字段名称。比如：{name:sam phone:{mobile:12345 office:67890} %#v 用Go的语法打印，比如main.People{name:”sam”, phone:main.Phone{mobile:”12345”, office:”67890”}} Boolean %t 打印true或false Pointer %p 带0x的指针 %#p 不带0x的指针 printf和println的区别Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形 Println : 可以打印出字符串，和变量 END]]></content>
      <categories>
        <category>《Go语言编程》笔记</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念我人生的第一次转岗]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%89%8D%E7%AB%AF%E8%BD%AC%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[今天做了一个重大的决定，那就是前端转后台，从JavaScript到Golang。垫显示器的书将要永远垫着了… 虽然作抉择的时候彻夜难眠，但确实没有焦虑，而是在认真的一点一点地剖析两个方向、两个选择的结果。很多很多的因素，自己很难捋清楚，问了很多人，得到了各种建议，但最后将要做决定的时候，才发现还是要问自己才行。 入职培训我一直记得一句话叫做：“简单相信”，但真的让自己做选择时，相信别人的安排又是那么困难。 在面临一些重要决定时，我总是会想到父亲，在我眼里，父亲是一个活得很明白，生活阅历丰富的人。他的建议对我的人生轨迹有着很大的助力作用。父亲觉得年轻就是要多学多闯，要看得见远方，舍弃当下看似很难以割舍的东西，去追求长远的目标。 有人说：只有有能力的人才拥有选择权。但我认为有能力的人拥有的不是选择权，而是制造选择的能力。 END]]></content>
      <categories>
        <category>人生纪实</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中Next主题首页不显示全文]]></title>
    <url>%2F2018%2F03%2F14%2FHexo%E4%B8%ADNext%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[使用Next主题时，会发现它在首页默认是会显示全文的，这就很不方便浏览文章列表。 解决办法找到主题配置文件```yml# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: fales length: 150 将enable的值修改为true，而length是指显示的字数，然后重新部署就可以了~ Tips：使用预览会忽略文章的格式，直接显示为正文文本。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-theme</tag>
        <tag>theme-next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie安全探索]]></title>
    <url>%2F2018%2F03%2F14%2FCookie%E5%AE%89%E5%85%A8%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[在使用前端保存数据时，我通常会使用LocalStorage，相较于Cookie，前者更方便，容量更大，而且保存时间长。但是对于后端来说，我们同样需要在前端保存一些数据并与之交互，也就是在HTTP头中携带Cookie。 Cookie的基本属性 name（名称） value（值） domain（子域） path（站点路径） expires/Max-Age（过期时间） Size（大小） http（仅HTTP读取） secure（安全性） 具体的属性用法，网上都有介绍，就不一一赘述 Cookie安全问题 不唯一：Cookie是由三元组[name, domain, path]来确定的，是会出现重名，即不是唯一的 易于获取：前面提到了Cookie是被携带在HTTP上面的，所以很容易从请求上截取到Cookie Cookie注入：容易截取的同时，Cookie也易于修改 思考基于上面的问题，我有思考过当前我所做的项目存在的安全问题，虽然只是一个内部的管理页面，有内网限制。但公司员工如果发现安全漏洞，岂不是可以攻击系统了。 看了很多相关的博文，对我当前项目的Cookie进行了一些基础的防护： 将一些较为敏感的信息作为post请求字段进行传递 对系统的用户输入提交进行脚本过滤 设置secure为true 设置HTTPOnly属性 定期自动清理一些不必要的Cookie字段 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git子模块-初遇]]></title>
    <url>%2F2018%2F03%2F05%2FGit%E5%AD%90%E6%A8%A1%E5%9D%97-%E5%88%9D%E9%81%87%2F</url>
    <content type="text"><![CDATA[使用Git已经有好几年了，但是从来没有使用过Git的子模块，因为大多数项目都是独立的，项目之间并没有包含关系。所谓子模块，也就是将一个Git仓库作为另一个Git仓库的子目录，然后在大的仓库里进行模块化管理子仓库。 问题初探在搭建Blog的过程中，有使用到Hexo的主题next，在提交代码到Git上时，发现next文件无法commit： $ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: themes/next (modified content)no changes added to commit (use "git add" and/or "git commit -a") 看了一下网上的解释，原来是因为我是clone的代码，next文件下有.git的存在，只需要删除就可以。删除虽然可以解决问题，但这样就无法更新next了，如果下载后手动合并自己的修改又过于麻烦。而且由于我是深度修改了next，很多文件都进行了修改，所以无法像issues那样，提取个人的配置，不对next进行修改。 子模块使用这时候看到有人提到了fork+submodule的方法，大概意思就是将next项目fork到自己的GitHub上，然后clone下来并作为子模块进行管理，这样既可以修改next并上传保存，也可以update作者的代码。 操作步骤先clone并建立子模块 $ git submodule add https://github.com/zj972/hexo-theme-next themes/next 进行完这一步操作就会clone仓库代码到对应路径，同时还会在根目录下生成一个.gitmodules文件，该配置文件保存着仓库链接和本地目录的映射关系： $ cat .gitmodules[submodule "themes/next"] path = themes/next url = https://github.com/zj972/hexo-theme-next 然后就可以进行子模块的修改和操作了，作为刚用上这个命令不太熟的，其实可以直接进入到子仓库目录下进行git操作。 一下是几条操作的示例： 查看详细的差异信息 $ git diff --cached --submodule 克隆包含有子模块的项目 $ git clone git@github.com:zj972/blog.git 这个时候子模块目录是空的，需要通过submodule进行更新 $ git submodule init$ git submodule update 其他的子模块操作还在尝试中… END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Page绑定个人域名]]></title>
    <url>%2F2018%2F03%2F02%2FGitHub_Page%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[自己的服务器到期了，然后打算在GitHub上面搭个个人博客玩玩，最后选择了Hexo。搭建起来后，用自己的域名绑定了GitHub Page。 但是遇到一个问题：每次hexo d -g之后，访问www.yangshaobo.cn就变成了404。DNS解析是正常的，打开项目的setting，却发现Custom domain的值为空。 发现问题原来当你添加个人域名时，GitHub会向你的项目仓库添加一个文件CNAME，里面包含了一个域名： www.yangshaobo.cn 而每次我使用通过Hexo部署时都会自动提交public文件夹到仓库里，配置信息如下： deploy: type: git repository: git@github.com:zj972/zj972.github.com.git branch: master 这样就把CNAME文件自动覆盖了。 解决方案解决办法就是把CNAME文件添加到source文件夹里，这样每次部署就不会覆盖掉了。 END]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
